1.有序数组的平方 977
非降序数组 求平方后依旧是非降序
存在负数的平方等问题
暴力解法
首先计算平方，再进行大小排序
class Solution {
public:
    vector<int> sortedSquares(vector<int>& A) {
       for(int i=0; i<A.size(); i++){
        A[i]=A[i]*A[i];
       }
       sort(A.begin(),A.end());
       return A;
    }
};

2.双指针
最大元素只会在两边
两边向中间比较
一个指针从数组开端 一个从末端开始比较
哪个大 哪个就是新数组的最后一个下标的数
class Solution {
public:
    vector<int> sortedSquares(vector<int>& A) {
     int k = A.size()-1;
     vector<int> result(A.size(),0);
       for(int i=0, j=A.size()-1; i<=j; ){
        if(A[i]*A[i]<A[j]*A[j]){
            result[k--]= A[j]*A[j];
            j--;
        }
        else{
            result[k--]= A[i]*A[i];
            i++;
        }
       }
       return result;
    }
};
2. 长度最小的子数组
暴力解法：
遍历所有数，求和 求长度
i作为起始位置 j作为终止位置
从头开始遍历数组 求和
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
      int sum = 0;
      int length = 0;
      int result = INT32_MAX; //使最终值的初始值为最大
      for(int i=0; i<nums.size(); i++){
             sum = 0;  // i更新后 重新计算总和
            for(int j=i; j<nums.size();j++){
                sum += nums[j];
                if (sum>=target){
                    length = j-i+1;
                    result = min(result,length);
                    break; //一旦找到符合的数组 就退出
                }
            }
      }
      // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
          
};
